<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on 知止堂</title><link>https://comfluter.life/tags/python/</link><description>Recent content in Python on 知止堂</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 07 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://comfluter.life/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenCV 学习随记</title><link>https://comfluter.life/p/opencv-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://comfluter.life/p/opencv-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</guid><description>Installation pip install opencv-python
Reading and Saving Images 函数 cv2.imwrite()用于将图像保存到指定的文件
retval = cv2.imwrite(filename, img [, paras])
cv2.imwrite() 将 OpenCV 图像保存到指定的文件。 cv2.imwrite() 基于保存文件的扩展名选择保存图像的格式。 cv2.imwrite() 只能保存 BGR 3通道图像，或 8 位单通道图像、或 PNG/JPEG/TIFF 16位无符号单通道图像。 Arguments filename：要保存的文件的路径和名称，包括文件扩展名 img：要保存的 OpenCV 图像，nparray 多维数组 paras：不同编码格式的参数，可选项 cv2.CV_IMWRITE_JPEG_QUALITY：设置 .jpeg/.jpg 格式的图片质量，取值为 0-100（默认值 95），数值越大则图片质量越高； cv2.CV_IMWRITE_WEBP_QUALITY：设置 .webp 格式的图片质量，取值为 0-100； cv2.CV_IMWRITE_PNG_COMPRESSION：设置 .png 格式图片的压缩比，取值为 0-9（默认值 3），数值越大则压缩比越大。 retval：返回值，保存成功返回 True，否则返回 False。 Notice cv2.imwrite() 保存的是 OpenCV 图像（多维数组），不是 cv2.imread() 读取的图像文件，所保存的文件格式是由 filename 的扩展名决定的，与读取的图像文件的格式无关。 对 4 通道 BGRA 图像，可以使用 Alpha 通道保存为 PNG 图像。 cv2.</description></item><item><title>Anaconda使用随记</title><link>https://comfluter.life/p/anaconda%E4%BD%BF%E7%94%A8%E9%9A%8F%E8%AE%B0/</link><pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate><guid>https://comfluter.life/p/anaconda%E4%BD%BF%E7%94%A8%E9%9A%8F%E8%AE%B0/</guid><description>基本命令 创建虚拟环境：conda create -n &amp;lt;env_name&amp;gt; python=X.X 查看环境信息：conda info --envs 激活虚拟环境：conda activate &amp;lt;env_name&amp;gt; 删除环境：conda remove -n &amp;lt;env_name&amp;gt; --all 添加软件源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r conda config --set show_channel_urls yes Minutiae unable auto activate base: conda config --set auto_activate_base false</description></item><item><title>Pyspice 学习随记</title><link>https://comfluter.life/p/pyspice-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</link><pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate><guid>https://comfluter.life/p/pyspice-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</guid><description>Environment config Initialize the python virtual environmentvirtualenv .venv activate venv (windows system) .venv/Scripts/activate install packages used in pyspice pip install pyspice pip install opencv-python for image output install ngspice dll libraries installation: pyspice-post-installation --install-ngspice-dll check: pyspice-post-installation --check-install OS is Windows Found in library search path: None Load NgSpiceShared Load library D:\Work\04_Research_Project\21.08.19_Early_Visual_Processing\pyspice\.venv\lib\site-packages\PySpice\Spice\NgSpice\Spice64_dll\dll-vs\ngspice.dll Ngspice version is 34 has xspice: True has cider True &amp;gt; version -f ****** ** ngspice-34 : Circuit level simulation program ** The U.</description></item><item><title>Numpy 学习随记</title><link>https://comfluter.life/p/numpy-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</link><pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate><guid>https://comfluter.life/p/numpy-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</guid><description>数组切片 import numpy as np a = np.array([[11, 12, 13], [21, 22, 23]], [31, 32, 33]) 注意Numpy中元素编号从0开始，左侧包含右侧不包含
取单个元素x = a[1, 2]，对应第0维的第1个元素4 切片x = a[0:2, 1:3]，对应第0维的第0~1个元素，第1维的第1~2个元素[[12 13], [22 23]] 切片x = a[:2, 2:]，对应对应第0维的最开始到第2（2-1）个元素，第1维的第2个及以后的所有元素[[13], [23]] 判断一个数组是否存在于另一个大数组内 直接使用==会逐数字判断元素是否存在：
import numpy as np a = np.array([[1, 2, 3], [2, 3, 4]]) print(a == np.array([1, 2, 3])) 可以改为(a == np.array([1, 2, 3])).all(1).any()。y == z会将y的每一行与z的每个元素进行比较。 使用all(axis=1)可以获取所有元素匹配的行，并使用any()找出是否匹配。
import numpy as np a = np.array([[1, 2, 3], [2, 3, 4]]) print(a == np.</description></item><item><title>Python 学习随记</title><link>https://comfluter.life/p/python-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</link><pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate><guid>https://comfluter.life/p/python-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</guid><description>Python Module Python Module 导入方法 import &amp;lt;module name&amp;gt;调用这个方法导入的module中的函数时，需要&amp;lt;module name&amp;gt;.&amp;lt;function name&amp;gt;格式进行使用 from &amp;lt;module name&amp;gt; import &amp;lt;sth&amp;gt;从某个模块中引入某些特殊函数等引入现在所在的全局命名空间中，直接使用&amp;lt;sth&amp;gt;就可以进行使用。这里引入的可以是一个子包，也可以是子包中的任意对象。 from &amp;lt;module name&amp;gt; import *将模块中所有对象引入，直接使用原模块中的名称即可使用 搜索路径 导入一个模块时，Python 解析器对模块位置的搜索顺序是：
当前目录 如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。 模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 命名空间和作用域 变量：名字与匹配对象的对应 命名空间：记录了所有名字-对象对应关系的字典 python表达式可以访问全局/局部命名空间，重名时局部命名空间优先。 使用global语句可以告诉python变量属于全局变量。ex.global x
导入本地自定义包 文件结构
main.py package |--__init__.py |--module1.py |--module2.py 包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。
简单来说，包就是文件夹，但该文件夹下必须存在__init__.py 文件, 该文件的内容可以为空。__init__.py 用于标识当前文件夹是一个包。
假设module1.py中有函数func1()，则在main函数中可以使用以下集中方式进行包导入：
import mymodule.module1此时对应func1()的调用为mymodule.module1.func1()，前缀较长，比较繁琐。 import mymodule.module1 as m1此时对应func1()的调用为m1.func1() from mymodule import module1此时对应func1()的调用为module1.</description></item></channel></rss>